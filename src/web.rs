//! This file is the server side of the web interface.
//!
//! The client-side code consists of:
//!     - Everything in the `web_static` directory.
//!     - Snippets of HTML code generated by the `maud::html` macro.

use axum::{
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post, put},
};
use gstreamer::ClockTime;
use tokio::sync::oneshot;

#[derive(serde::Deserialize)]
struct SliderValue {
    value: i32,
}
/// An enum of all the events/commands received from client side
#[derive(Debug)]
pub enum Event {
    ButtonPressed,
    SliderMoved {
        value: i32,
    },
    /// Received when client side requests structure holding the program status,
    /// typically when the page is loaded
    RequestRRadioStatusReport {
        report_tx: oneshot::Sender<Result<String, std::fmt::Error>>,
    },
    /// client side wants to set the play position to the given value
    UpdatePosition {
        position_ms: u64,
    },
}

/// Real-time information as sent to client.
#[derive(Clone)]
pub enum DataChanged {
    /// Position & Duration as sent to client
    Position {
        position: ClockTime,
        duration: Option<ClockTime>,
    },
}

/// Receiving end of data received from main loop (in "main")
struct DataChangedReceiver {
    data_changed_rx: tokio::sync::broadcast::Receiver<DataChanged>,
}

impl Clone for DataChangedReceiver {
    fn clone(&self) -> Self {
        // Queued messages are lost, but that's OK as future message will correct this
        Self {
            data_changed_rx: self.data_changed_rx.resubscribe(),
        }
    }
}

/// Sending end of events sent to main loop (in "main")
#[derive(Clone)]
struct EventsTx {
    events_tx: tokio::sync::mpsc::UnboundedSender<Event>,
}

/// state of the web server
#[derive(Clone)]
struct ServerState {
    events_tx: EventsTx,
    data_changed_rx: DataChangedReceiver,
}

/// Allows us to use DataChangedReceiver in request handlers.
impl axum::extract::FromRequestParts<ServerState> for DataChangedReceiver {
    // FromRequestParts requires a "Failure" type.
    // Given how getting a DataChangedReceiver cannot fail, the "Failure" type is `Infallible`.
    type Rejection = core::convert::Infallible;

    /// Extracts & returns the DataChangedReceiver (ie state.data_changed_rx) from a request
    async fn from_request_parts(
        _request_parts: &mut axum::http::request::Parts,
        state: &ServerState,
    ) -> Result<Self, Self::Rejection> {
        Ok(state.data_changed_rx.clone())
    }
}

/// Allows us to use EventsTx in request handlers.
impl axum::extract::FromRequestParts<ServerState> for EventsTx {
    // FromRequestParts requires a "Failure" type.
    // Given how getting a EventsTx cannot fail, the "Failure" type is `Infallible`.
    type Rejection = core::convert::Infallible;

    /// Extracts & returns the EventsTx (ie state.events_tx) from a request
    async fn from_request_parts(
        _request_parts: &mut axum::http::request::Parts,
        state: &ServerState,
    ) -> Result<Self, Self::Rejection> {
        Ok(state.events_tx.clone())
    }
}

/// The Request Handler for the rradio status report.
async fn handle_rradio_status_report(
    EventsTx { events_tx }: EventsTx,
) -> Result<axum::response::Response, axum::response::Response> {
    // a oneshot channel can only send a single message.
    // eg if one thing send a message, it can only have a single reply
    let (report_tx, report_rx) = oneshot::channel();

    events_tx
        .send(Event::RequestRRadioStatusReport { report_tx })
        .map_err(|_| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to send RequestRRadioStatusReport Event to main loop",
            )
                .into_response()
        })?;

    report_rx
        .await
        .map_err(|_| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Main loop never sent report",
            )
                .into_response()
        })?
        .map_err(|std::fmt::Error| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to format rradio status report",
            )
                .into_response()
        })
        .map(IntoResponse::into_response)
}

/// render from data to HTML in the form that the inital test page expects
/// TBD decide if I keep the test page.
fn render_test_events_data_changed(
    data_changed: DataChanged,
) -> Result<axum::response::sse::Event, core::convert::Infallible> {
    use maud::Render;

    Ok(match data_changed {
        DataChanged::Position { position, duration } => {
            let data = match duration {
                Some(duration) => maud::html! {
                    input type="range" // Create a slider
                        min="0" max=(duration.mseconds()) value=(position.mseconds())
                        // When the slider is moved by the user, send a PUT request
                        // with a form value named "position_ms" with the new slider value.
                        name="position_ms" hx-put="/api/position" hx-swap="none"

                        // Allows HTMX to not swap out the slider if the user is currently dragging the slider.
                        onpointerdown="this.dataset.dragging = 'true'"
                        onpointerup="this.dataset.dragging = 'false'"
                        onpointercancel="this.dataset.dragging = 'false'"
                        ontouchstart="this.dataset.dragging = 'true'"
                        ontouchend="this.dataset.dragging = 'false'"
                        ontouchcancel="this.dataset.dragging = 'false'"
                        ;
                }
                .render(), // Render to HTML
                None => maud::html! { input type="range" disabled; }.render(),
            };

            // Create the SSE Event which will be returned (inside OK(...))
            axum::response::sse::Event::default()
                .event("position-changed")
                .data(data.into_string())
        }
    })
}

/// Handle a request for test events by the client.
async fn handle_test_events(
    DataChangedReceiver { data_changed_rx }: DataChangedReceiver,
) -> axum::response::Response {
    use futures_util::StreamExt;

    let event_stream = tokio_stream::wrappers::BroadcastStream::new(data_changed_rx)
        .filter_map(async |data_changed| data_changed.ok())
        .map(render_test_events_data_changed);

    axum::response::Sse::new(event_stream).into_response()
}

/// Configure and start the web server.
pub fn start_server() -> (
    tokio::sync::broadcast::Sender<DataChanged>,
    tokio::sync::mpsc::UnboundedReceiver<Event>,
) {
    // Setup the comms channel for the server to notify the main loop of commands.
    let (events_tx, events_rx) = tokio::sync::mpsc::unbounded_channel::<Event>();

    // Setup the comms channel for the main loop to notify the client of data changing.
    const DATA_CHANGED_MESSAGE_QUEUE_SIZE: usize = 20; // The maximum number of messages queued before they are dropped, due to a backlog.
    let (data_changed_tx, data_changed_rx) =
        tokio::sync::broadcast::channel(DATA_CHANGED_MESSAGE_QUEUE_SIZE);

    // Spawn the web server on the Pi
    tokio::spawn(async move {
        // move causes mentioned variables to be moved into the async block (& no longer accessible outside of the block).

        // Declare the api routes for making API calls into the Pi.
        // this router is nested inside the router called "app", so cannot be seen externally
        let api_router = axum::Router::new()
            .route("/test-events", get(handle_test_events))
            .route(
                // this route is used to push new positions from the client to the server
                "/position", // this line says it is to do with "/position"
                put({
                    #[derive(serde::Deserialize)]
                    struct Position {
                        position_ms: u64,
                    }
                    // The next line is the actual handler
                    async |EventsTx { events_tx }, axum::extract::Form(Position { position_ms })| {
                        // Next line cannot fail unless the main thread terminates without this one ending too.
                        let _ = events_tx.send(Event::UpdatePosition { position_ms });
                    }
                }),
            )
            .route(
                "/button-press",
                post(async |EventsTx { events_tx }| {
                    _ = events_tx.send(Event::ButtonPressed);
                }),
            )
            .route(
                "/slider-move",
                post(
                    async |EventsTx { events_tx }, axum::Form(SliderValue { value })| {
                        _ = events_tx.send(Event::SliderMoved { value });

                        // Generate a HTML snippet using a templating engine, see https://maud.lambda.xyz/
                        maud::html! {
                            div {
                                "Slider position: " (value)
                            }
                        }
                    },
                ),
            );

        // The top-level application router, called whenever the client makes an HTTP request
        let app = memory_serve::MemoryServe::new(memory_serve::load_assets!("web_static"))
            .into_router()
            .nest("/api", api_router) // strip "/api" from the start of the path and forward to "api_router"
            .route("/1", get(handle_rradio_status_report))
            .with_state(ServerState {
                events_tx: EventsTx { events_tx },
                data_changed_rx: DataChangedReceiver { data_changed_rx },
            });

        // start the web server on the specified port
        axum::serve(
            // "UNSPECIFIED" means any IP address can connect to the specified port on the web server.
            tokio::net::TcpListener::bind((std::net::Ipv4Addr::UNSPECIFIED, 80))
                .await
                .unwrap(),
            app,
        )
        .await
        .unwrap();
    });

    (data_changed_tx, events_rx)
}
