//! This file is the server side of the web interface.
//!
//! The client-side code consists of:
//!     - Everything in the `web_static` directory.
//!     - Snippets of HTML code generated by the `maud::html` macro.

use axum::{
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post, put},
};
use gstreamer::ClockTime;
use tokio::sync::oneshot;

#[derive(serde::Deserialize)]
struct SliderValue {
    value: i32,
}

/// Gives the index number of the episode that a user has selected.
#[derive(serde::Deserialize)]
struct EpisodeSelected {
    episode_index: usize,
}


/// Gives the index number of the podcast that a user has selected.
/// used when the user has changed the podcast they want ie they want "the Archers"

#[derive(serde::Deserialize)]
struct PodcastIndex {
    podcast_index: i32,
}


#[derive(serde::Deserialize)]
struct PodcastText {
    new_podcast_text: String,
}

/// a struct of all the data that the Webserver needs to send to the client when the client starts
#[derive(Debug)]
pub struct WebPageStartupData{
    pub volume :i32,
    pub podcast_data_for_all_stations: Vec<PodcastDataFromToml>,
}


/// An enum of all the events/commands received from client side
#[derive(Debug)]
pub enum Event {
    /// We have received a request from the client for the startup data, 
    /// so forward the request to the main program
    RequestWebPageStartupData{web_page_startup_data_tx : oneshot::Sender<WebPageStartupData>},

    SliderMoved {
        value: i32,
    },

    /// User has specified the episode wanted, so forward that to the main program
    EpisodeSelected {
    /// Gives the index number of the episode that a user has selected.
       episode_index: usize,
    },

    /// Received when client side requests structure holding the program status,
    /// typically when the page is loaded
    RequestRRadioStatusReport {
        report_tx: oneshot::Sender<Result<String, std::fmt::Error>>,
    },
    /// get the RSS data & decode it.
    Getrss,
    
    /// user has pressed the volume down button, so inform the main program
    VolumeDownPressed,

    /// user has changed the dropdown box value to choose the podcast they want to hear
    /// They have still got to select the episode within the podcast at this point.
    PodcastIndexChanged{
        podcast_index: i32,
    },  

    /// user pressed the initialise <button
    PlayPause,
    VolumeUpPressed,
    /// client side wants to set the play position to the given value
    UpdatePosition {
        position_ms: u64,
    },
    PodcastText {
        new_podcast_text: String,
    },
}

use crate::{EpisodeDataForOnePodcastDownloaded, my_dbg};

use super::PodcastDataFromToml;

/// Real-time information as sent to client.
#[derive(Clone)]
pub enum DataChanged {
    /// gstreamer volume
    Volume(i32),
    /// Position & Duration as sent to client
    Position {
        position: ClockTime,
        duration: Option<ClockTime>,
    },
    /// The podcast data for all the channels as read from the TOML file, ie title & URL
    Podcast {
        podcast_data_from_toml: Vec<PodcastDataFromToml>,
    },
    /// the podcast data for one station, obtained by using selecting a station
    /// & then looking up the required data
    EpisodeDataForOnePodcast{episode_data_for_one_podcast: EpisodeDataForOnePodcastDownloaded,},
}

/// Receiving end of data received from main loop (in "main")
struct DataChangedReceiver {
    data_changed_rx: tokio::sync::broadcast::Receiver<DataChanged>,
}

impl Clone for DataChangedReceiver {
    fn clone(&self) -> Self {
        // Queued messages are lost, but that's OK as future message will correct this
        Self {
            data_changed_rx: self.data_changed_rx.resubscribe(),
        }
    }
}

/// Sending end of events sent to main loop (in "main")
#[derive(Clone)]
struct EventsTx {
    events_tx: tokio::sync::mpsc::UnboundedSender<Event>,
}

/// state of the web server
#[derive(Clone)]
struct ServerState {
    events_tx: EventsTx,
    data_changed_rx: DataChangedReceiver,
}

/// Allows us to use DataChangedReceiver in request handlers.
impl axum::extract::FromRequestParts<ServerState> for DataChangedReceiver {
    // FromRequestParts requires a "Failure" type.
    // Given how getting a DataChangedReceiver cannot fail, the "Failure" type is `Infallible`.
    type Rejection = core::convert::Infallible;

    /// Extracts & returns the DataChangedReceiver (ie state.data_changed_rx) from a request
    async fn from_request_parts(
        _request_parts: &mut axum::http::request::Parts,
        state: &ServerState,
    ) -> Result<Self, Self::Rejection> {
        Ok(state.data_changed_rx.clone())
    }
}

/// Allows us to use EventsTx in request handlers.
impl axum::extract::FromRequestParts<ServerState> for EventsTx {
    // FromRequestParts requires a "Failure" type.
    // Given how getting a EventsTx cannot fail, the "Failure" type is `Infallible`.
    type Rejection = core::convert::Infallible;

    /// Extracts & returns the EventsTx (ie state.events_tx) from a request
    async fn from_request_parts(
        _request_parts: &mut axum::http::request::Parts,
        state: &ServerState,
    ) -> Result<Self, Self::Rejection> {
        Ok(state.events_tx.clone())
    }
}

/// The Request Handler for the rradio status report.
async fn handle_rradio_status_report(
    EventsTx { events_tx }: EventsTx,
) -> Result<axum::response::Response, axum::response::Response> {
    // a oneshot channel can only send a single message.
    // eg if one thing sends a message, it can only have a single reply
    let (report_tx, report_rx) = oneshot::channel();

    events_tx
        .send(Event::RequestRRadioStatusReport { report_tx })
        .map_err(|_| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to send RequestRRadioStatusReport Event to main loop",
            )
                .into_response()
        })?;

    report_rx
        .await
        .map_err(|_| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Main loop never sent report",
            )
                .into_response()
        })?
        .map_err(|std::fmt::Error| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to format rradio status report",
            )
                .into_response()
        })
        .map(IntoResponse::into_response)
}

/// render from data to HTML in the form that the inital page expects
/// handles volume, position etc changes
fn render_events_data_changed(
    data_changed: DataChanged,
) -> Result<axum::response::sse::Event, core::convert::Infallible> {
    use maud::{Render, html};

    Ok(match data_changed {
        DataChanged::Podcast {
            podcast_data_from_toml,
        } => {
            // Create the SSE Event which will be returned (inside OK(...))
            axum::response::sse::Event::default()
                .event("podcast-changed-by-user")
                .data(
                    html!(  // this macro creates HTML from the contents of the brackets
                    {
                        select name="podcast_index" hx-post="/api/podcast-changed-by-user" hx-trigger="change" 
                        hx-swap="none" {
                            // generate the first value for the dropdown box
                            option value = (-1) {(" Select Podcast")}    // -1 denotes not a real value
                            // iterate over the stations & output the station name
                            @for count in 0.. podcast_data_from_toml.len(){     // for each podcast
                                // generate another value for the dropdown box
                                option value = (count) {(podcast_data_from_toml[count].title)}

                            /*
                            if the following code is used instead of the previous line, that will force the first line to be selected. 
                            but, showing the first line is the default
                            @if count == 0 {
                            option value = (count) selected {(podcast_data_from_toml[count].title)}
                            }
                            @else { option value = (count) {(podcast_data_from_toml[count].title)} }
                            */
                            }                               
                        }
                    }                 
                                    
                )
            .render()
            .into_string(),
            )
        }

        DataChanged::EpisodeDataForOnePodcast { episode_data_for_one_podcast } => {
            // Create the SSE Event which will be returned (inside OK(...))
                       
            axum::response::sse::Event::default()
                .event("list-of-episodes")
                .data(
                    maud::html!{ center{label { h2{ "podcast" (episode_data_for_one_podcast.channel_title) }}
                        p { (episode_data_for_one_podcast.description)}}
                        p { @for count in 0.. episode_data_for_one_podcast.data_for_multiple_episodes.len() {                       
                            p {(episode_data_for_one_podcast.data_for_multiple_episodes[count].date)}
                            p {(episode_data_for_one_podcast.data_for_multiple_episodes[count].summary)}
                            P { button  hx-post ="/api/list-of-episodes" hx-swap= "none" name ="episode_index" value = (count) 
                            { "Stream   " (episode_data_for_one_podcast.data_for_multiple_episodes[count].subtitle)} }
                            } // end of for loop content
                        } // end of for

                    }  
                        .render()
                        .into_string(),
                )            
        },

        DataChanged::Volume(volume) => {
            // Create the SSE Event which will be returned (inside OK(...))
            axum::response::sse::Event::default()
                .event("volume-changed")
                .data(
                    maud::html!({ "Volume:" (volume) } )
                        .render()
                        .into_string(),
                )
        }
        DataChanged::Position { position, duration } => {
            let data = match duration {
                Some(duration) => maud::html! {
                    input type="range" // Create a slider
                        min="0" max=(duration.mseconds()) value=(position.mseconds())
                        // When the slider is moved by the user, send a PUT request
                        // with a form value named "position_ms" with the new slider value.
                        name="position_ms" hx-put="/api/position" hx-swap="none"

                        // Allows HTMX to not swap out the slider if the user is currently dragging the slider.
                        onpointerdown="this.dataset.dragging = 'true'"
                        onpointerup="this.dataset.dragging = 'false'"
                        onpointercancel="this.dataset.dragging = 'false'"
                        ontouchstart="this.dataset.dragging = 'true'"
                        ontouchend="this.dataset.dragging = 'false'"
                        ontouchcancel="this.dataset.dragging = 'false'"
                        ;
                }
                .render(), // Render to HTML
                None => maud::html! { input type="range" disabled; }.render(),
            };

            // Create the SSE Event which will be returned (inside OK(...))
            axum::response::sse::Event::default()
                .event("position-changed")
                .data(data.into_string())
        }
    })
}

/// Handle a request for events by the client.
async fn handle_events(
    EventsTx { events_tx }: EventsTx,
    DataChangedReceiver { data_changed_rx }: DataChangedReceiver,
) -> Result<axum::response::Response,axum::response::Response> {
    use futures_util::StreamExt;

// a oneshot channel can only send a single message.
    // eg if one thing sends a message, it can only have a single reply
    let (web_page_startup_data_tx, web_page_startup_data_rx) = oneshot::channel();

    events_tx
        .send(Event::RequestWebPageStartupData { web_page_startup_data_tx  } )
        .map_err(|_| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to send request for startup data Event to main loop",
            )
                .into_response()
        })?;
        let WebPageStartupData { volume, podcast_data_for_all_stations } = 
            web_page_startup_data_rx.await.map_err(|_| {
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Failed to wait for  startup data from main loop",
            )
                .into_response()
        })?;

    let startup_events = futures_util::stream::iter([
        DataChanged::Volume(volume), DataChanged::Podcast { podcast_data_from_toml: podcast_data_for_all_stations }
    ]); 

    let event_stream = 
        startup_events.chain( tokio_stream::wrappers::BroadcastStream::new(data_changed_rx)
        .filter_map(async |data_changed| data_changed.ok()))
        .map(render_events_data_changed);

    Ok(axum::response::Sse::new(event_stream).into_response())
}

/// Configure and start the web server.
pub fn start_server() -> (
    tokio::sync::broadcast::Sender<DataChanged>,
    tokio::sync::mpsc::UnboundedReceiver<Event>,
) {
    // Setup the comms channel for the server to notify the main loop of commands.
    let (events_tx, events_rx) = tokio::sync::mpsc::unbounded_channel::<Event>();

    // Setup the comms channel for the main loop to notify the client of data changing.
    const DATA_CHANGED_MESSAGE_QUEUE_SIZE: usize = 20; 
// The maximum number of messages queued before they are dropped, due to a backlog.
    let (data_changed_tx, data_changed_rx) =
        tokio::sync::broadcast::channel(DATA_CHANGED_MESSAGE_QUEUE_SIZE);

    // Spawn the web server on the Pi
    tokio::spawn(async move {
        // move causes mentioned variables to be moved into the async block (& no longer accessible outside of the block).

        // Declare the api routes for making API calls into the Pi.
        // this router is nested inside the router called "app", so cannot be seen externally
        let api_router = axum::Router::new()
            .route("/main-page-events", get(handle_events))
            .route(
                // this route is used to push new positions from the client to the server
                "/position", // this line says it is to do with "/position"
                put({
                    #[derive(serde::Deserialize)]
                    struct Position {
                        position_ms: u64,
                    }
                    // The next line is the actual handler
                    async |EventsTx { events_tx }, axum::extract::Form(Position { position_ms })| {
                        // Next line cannot fail unless the main thread terminates without this one ending too.
                        let _ = events_tx.send(Event::UpdatePosition { position_ms });
                    }
                }),
            )
            
            .route(
                "/podcast-changed-by-user",
        post(async |EventsTx { events_tx }, axum::Form(PodcastIndex{podcast_index})| {
                    // the user has changed the podcast they want ie they want "the Archers"
                    _ = events_tx.send(Event::PodcastIndexChanged { podcast_index});

                }),
            )


            .route(
                "/get-rss",
                post(async |EventsTx { events_tx }| {
                    _ = events_tx.send(Event::Getrss);
                }),
            )
            .route(
                "/podcast-text",
                post(
                    async |EventsTx { events_tx }, axum::Form(PodcastText { new_podcast_text })| {
                        _ = events_tx.send(Event::PodcastText {
                            new_podcast_text: (new_podcast_text.trim().to_string()),
                            //we trim it in case there are leading or trailing spaces
                        });
                    },
                ),
            )
            .route(
                "/playpause",
                post(async |EventsTx { events_tx }| {
                    _ = events_tx.send(Event::PlayPause);
                }),
            )
            .route(
                "/volume-up",
                post(async |EventsTx { events_tx }| {
                    _ = events_tx.send(Event::VolumeUpPressed);
                }),
            )
            .route(
                "/volume-down",
                post(async |EventsTx { events_tx }| {
                    _ = events_tx.send(Event::VolumeDownPressed);
                }),
            )


            .route(
                "/list-of-episodes",
                post(
                    async |EventsTx { events_tx }, axum::Form(EpisodeSelected { episode_index })| {
                        _ = events_tx.send(Event::EpisodeSelected { episode_index });

  
                    },
                ),
            )            
            .route(
                "/slider-move",
                post(
                    async |EventsTx { events_tx }, axum::Form(SliderValue { value })| {
                        _ = events_tx.send(Event::SliderMoved { value });

                        // Generate a HTML snippet using a templating engine, see https://maud.lambda.xyz/
                        maud::html! {
                            div {
                                "Slider position: does not do anything currently" (value)
                            }
                        }
                    },
                ),
            );
            

        // The top-level application router, called whenever the client makes an HTTP request
        let app = memory_serve::MemoryServe::new(memory_serve::load_assets!("web_static"))
            .into_router()
            .nest("/api", api_router) // strip "/api" from the start of the path and forward to "api_router"
            .route("/1", get(handle_rradio_status_report))
            .with_state(ServerState {
                events_tx: EventsTx { events_tx },
                data_changed_rx: DataChangedReceiver { data_changed_rx },
            });

        // start the web server on the specified port
        axum::serve(
            // "UNSPECIFIED" means any IP address can connect to the specified port on the web server.
            tokio::net::TcpListener::bind((std::net::Ipv4Addr::UNSPECIFIED, 80))
                .await
                .unwrap(),
            app,
        )
        .await
        .unwrap();
    });

    (data_changed_tx, events_rx)
}
